<?xml version="1.0" encoding="UTF-8"?>
<xwikidoc>
<web>Lib</web>
<name>LivetableDataAdapter</name>
<language></language>
<defaultLanguage>en</defaultLanguage>
<translation>0</translation>
<parent>Main.SpaceIndex</parent>
<creator>XWiki.Admin</creator>
<author>XWiki.Admin</author>
<customClass></customClass>
<contentAuthor>XWiki.Admin</contentAuthor>
<creationDate>1376364375000</creationDate>
<date>1376477240000</date>
<contentUpdateDate>1376477240000</contentUpdateDate>
<version>16.1</version>
<title>LivetableDataAdapter</title>
<defaultTemplate></defaultTemplate>
<validationScript></validationScript>
<comment></comment>
<minorEdit>false</minorEdit>
<syntaxId>xwiki/2.1</syntaxId>
<hidden>false</hidden>
<content>{{include document="Lib.MongoDBConnection"/}}
{{groovy}}
    import groovy.json.*
    if(request.xpage == "plain") {
	response.setContentType('text/html')
    }    
    def rootLivetableRowList = []
    def rootLivetableData = [:]
    def legacyData = []
    def sortedResultData = [:]
    def dataModel = []
	
    def job = request.get("job")
	
    def fromDate = request.get("fromDate")	
    def toDate = request.get("toDate")
    def limit= (request.get("limit")!=null)?request.get("limit").toInteger():10
	
    def page = request.get("page")
    def rows = (request.get("rows") != null &amp;&amp; !request.get("rows").equals(""))?request.get("rows"):20
    def sidx = request.get("sidx")
    def sord = request.get("sord")
    def genPam = request.get("genp")
    def istIid = request.get("istIid")
    def subType = request.get("subType")
    if(subType != null)
        subType = subType.replaceAll("\"","")
    	
    
    def str= "No data were retrieved!"
    def result = null
    if(job!="" &amp;&amp; job!=null &amp;&amp; istIid != null &amp;&amp; !istIid.equals("")){
        MongoDBConnection.getConnection()
        if(fromDate != "" || toDate != ""){
            result = MongoDBConnection.getDataInPeriod(job,fromDate,toDate,limit,istIid)
        } else {
            result = MongoDBConnection.getDataAllFields(job,limit,istIid)
        }
        MongoDBConnection.closeConnection()       
        
		def idx =0               
		result.each{rec-&gt;		
			//-- get a list of data row
			legacyData = rec['data']
			subtractData = []
			//-- Parsing data and assign data to subtract list
			if(subType == null || subType.equals("")){ //-- Store
				subtractData = legacyData
			}else{ //-- Subtype
				def subTypeDataList = legacyData[subType]
				subtractData = subTypeDataList
			}	
            
			subtractData.each{r2-&gt;
					def livetableRows = [:]
					livetableRows['id'] = rec['fetchAt'] + "_" + idx				
					//-- replace CRLF in values to avoid JSON.parse error				
					def values = new ArrayList&lt;String&gt;(r2.values())
					livetableRows['cell'] = []
                    def newdate = new Date().parse("yyyyMMddHHmmssz", rec['fetchAt'])
                    livetableRows['cell'].add(newdate.format('yyyy/MM/dd HH:mm:ss z'))
					values.each{s-&gt;
					    if(s instanceof java.lang.String){
						    def newVal = s.replaceAll("\\\\","/")
							s = newVal.replaceAll("\r\n","")
							newVal = s.replaceAll("\r","")
							s = newVal.replaceAll("\n","")
						    livetableRows['cell'].add(s)
						}else
						  livetableRows['cell'].add(s)
					}
					if(dataModel != null &amp;&amp; dataModel.size() &lt;=0){ 
						dataModel = new ArrayList&lt;String&gt;(r2.keySet());
					}
					rootLivetableRowList.add(livetableRows)
					idx++
				}	
		}		
		rootLivetableData["records"] = rootLivetableRowList.size()
		
		rootLivetableData["total"] =  Math.round(rootLivetableRowList.size()/rows.toInteger())  //total page 
		rootLivetableData["page"] = (page != null)?page:1
		rootLivetableData["rows"] = rootLivetableRowList
		rootLivetableData["userdata"] = [:]
		rootLivetableData["dataModel"] = dataModel 
				
		sortedResultData = rootLivetableRowList		
		//-- convert sidx to 
		if(sord != null){
		   //-- sorting
		   def arrayMap1 = rootLivetableRowList.toArray(rootLivetableRowList)
		   Arrays.sort(arrayMap1, new Comparator() {
			   public int compare(arg0, arg1) {
					def p = arg1
					def n = arg0
					//-- sort by id first, late we sort by sidx req. pam.
					int lv = (sord.equals("desc"))?p["id"].compareTo(n["id"]):n["id"].compareTo(p["id"])
					if (lv &gt; 0) {
							return 1
					} else if (lv &lt; 0) {
							return -1
					} else {
							return 0
					}
						return lv
				}
			})				
			sortedResultData = arrayMap1			
			//-- Apply filter based on rows and page of request parameters
			if(rows != null &amp;&amp; page != null){				
				def startNum = rows.toInteger()*(page.toInteger() - 1)
				def endNum = rows.toInteger()*page.toInteger()-1
				if (arrayMap1.size() &gt; rows.toInteger()) {
					sortedResultData = arrayMap1.getAt(startNum..endNum)
				} else {
					sortedResultData = arrayMap1
				}
			}
			rootLivetableData["rows"] = sortedResultData
		}		
		//if( rootLivetableData != null &amp;&amp; rootLivetableData.size() &gt; 0 ){		
			//-- Parsing generate parameter 
			def builder = new JsonBuilder(rootLivetableData)		
			if(genPam != null &amp;&amp; genPam.equals("1")){
			    def pagerName = request.get("pager")
				if(pagerName == null || pagerName.equals(""))
				   str = "Must specify parameter pager incase you want to build data model (with genp parameter)"				
				def dataUrl =  ""
				if(subType == null || subType == "")
					dataUrl = "/xwiki/bin/get/Lib/LivetableDataAdapter?outputSyntax=plain&amp;job="+job +"&amp;limit="+limit+"&amp;fromDate="+fromDate + "&amp;toDate=" + toDate + "&amp;istIid="+istIid
				else
					dataUrl = "/xwiki/bin/get/Lib/LivetableDataAdapter?outputSyntax=plain&amp;job="+job +"&amp;limit="+limit+"&amp;fromDate="+fromDate + "&amp;toDate=" + toDate + "&amp;istIid="+istIid+"&amp;subType="+subType
				
				//-- Building data model				
				def model = []
				def colSpec
				dataModel.each{name-&gt;
				    colSpec = [:]
					colSpec['name'] = name
					colSpec['index'] = name
					colSpec['width'] = "100"
					model.add(colSpec)
				}
				def dataModelStr = (new JsonBuilder(dataModel)).toPrettyString()
				def modelStr = (new JsonBuilder(model)).toPrettyString() 

				def sortStr = (sord == null || sord.equals(""))?"asc":sord				
				str = 
				"{\"url\":\""+dataUrl+"\",\"datatype\":\"json\","+
					"\"colNames\":"+ dataModelStr +
					",\"colModel\":"+ modelStr +" ,\"rowList\":[10,20,30],"+
					"\"pager\":\"#"+pagerName+"\", \"viewrecords\": true, \"sortname\": \"RECORD_SEQ\","+
					"\"sortorder\": \""+ sortStr +"\", \"caption\":\""+job+"\"}"
				println str 
				
			}else{					
				str = builder.toPrettyString()							
				println str 
			}				
		//}		
    }
    
{{/groovy}}</content>
<versions>head	16.1;
access;
symbols;
locks; strict;
comment	@# @;


16.1
date	2013.08.14.19.47.20;	author XWiki_2EAdmin;	state full;
branches;
next	15.1;

15.1
date	2013.08.14.19.45.41;	author XWiki_2EAdmin;	state diff;
branches;
next	14.1;

14.1
date	2013.08.14.19.32.08;	author XWiki_2EAdmin;	state diff;
branches;
next	13.1;

13.1
date	2013.08.14.19.04.51;	author XWiki_2EAdmin;	state full;
branches;
next	12.5;

12.5
date	2013.08.13.13.54.43;	author XWiki_2EAdmin;	state diff;
branches;
next	12.4;

12.4
date	2013.08.13.13.45.25;	author XWiki_2EAdmin;	state diff;
branches;
next	12.3;

12.3
date	2013.08.13.13.42.14;	author XWiki_2EAdmin;	state diff;
branches;
next	12.2;

12.2
date	2013.08.13.13.40.51;	author XWiki_2EAdmin;	state diff;
branches;
next	12.1;

12.1
date	2013.08.13.13.40.13;	author XWiki_2EAdmin;	state full;
branches;
next	11.3;

11.3
date	2013.08.13.13.34.20;	author XWiki_2EAdmin;	state diff;
branches;
next	11.2;

11.2
date	2013.08.13.13.31.53;	author XWiki_2EAdmin;	state diff;
branches;
next	11.1;

11.1
date	2013.08.13.13.09.31;	author XWiki_2EAdmin;	state diff;
branches;
next	10.31;

10.31
date	2013.08.13.12.26.15;	author XWiki_2EAdmin;	state diff;
branches;
next	;


desc
@@


16.1
log
@@
text
@&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xwikidoc&gt;
&lt;web&gt;Lib&lt;/web&gt;
&lt;name&gt;LivetableDataAdapter&lt;/name&gt;
&lt;language&gt;&lt;/language&gt;
&lt;defaultLanguage&gt;en&lt;/defaultLanguage&gt;
&lt;translation&gt;0&lt;/translation&gt;
&lt;parent&gt;Main.SpaceIndex&lt;/parent&gt;
&lt;creator&gt;XWiki.Admin&lt;/creator&gt;
&lt;author&gt;XWiki.Admin&lt;/author&gt;
&lt;customClass&gt;&lt;/customClass&gt;
&lt;contentAuthor&gt;XWiki.Admin&lt;/contentAuthor&gt;
&lt;creationDate&gt;1376364375000&lt;/creationDate&gt;
&lt;date&gt;1376477240000&lt;/date&gt;
&lt;contentUpdateDate&gt;1376477240000&lt;/contentUpdateDate&gt;
&lt;version&gt;16.1&lt;/version&gt;
&lt;title&gt;LivetableDataAdapter&lt;/title&gt;
&lt;defaultTemplate&gt;&lt;/defaultTemplate&gt;
&lt;validationScript&gt;&lt;/validationScript&gt;
&lt;comment&gt;&lt;/comment&gt;
&lt;minorEdit&gt;false&lt;/minorEdit&gt;
&lt;syntaxId&gt;xwiki/2.1&lt;/syntaxId&gt;
&lt;hidden&gt;false&lt;/hidden&gt;
&lt;content&gt;{{include document="Lib.MongoDBConnection"/}}
{{groovy}}
    import groovy.json.*
    if(request.xpage == "plain") {
	response.setContentType('text/html')
    }    
    def rootLivetableRowList = []
    def rootLivetableData = [:]
    def legacyData = []
    def sortedResultData = [:]
    def dataModel = []
	
    def job = request.get("job")
	
    def fromDate = request.get("fromDate")	
    def toDate = request.get("toDate")
    def limit= (request.get("limit")!=null)?request.get("limit").toInteger():10
	
    def page = request.get("page")
    def rows = (request.get("rows") != null &amp;amp;&amp;amp; !request.get("rows").equals(""))?request.get("rows"):20
    def sidx = request.get("sidx")
    def sord = request.get("sord")
    def genPam = request.get("genp")
    def istIid = request.get("istIid")
    def subType = request.get("subType")
    if(subType != null)
        subType = subType.replaceAll("\"","")
    	
    
    def str= "No data were retrieved!"
    def result = null
    if(job!="" &amp;amp;&amp;amp; job!=null &amp;amp;&amp;amp; istIid != null &amp;amp;&amp;amp; !istIid.equals("")){
        MongoDBConnection.getConnection()
        if(fromDate != "" || toDate != ""){
            result = MongoDBConnection.getDataInPeriod(job,fromDate,toDate,limit,istIid)
        } else {
            result = MongoDBConnection.getDataAllFields(job,limit,istIid)
        }
        MongoDBConnection.closeConnection()       
        
		def idx =0               
		result.each{rec-&amp;gt;		
			//-- get a list of data row
			legacyData = rec['data']
			subtractData = []
			//-- Parsing data and assign data to subtract list
			if(subType == null || subType.equals("")){ //-- Store
				subtractData = legacyData
			}else{ //-- Subtype
				def subTypeDataList = legacyData[subType]
				subtractData = subTypeDataList
			}	
            
			subtractData.each{r2-&amp;gt;
					def livetableRows = [:]
					livetableRows['id'] = rec['fetchAt'] + "_" + idx				
					//-- replace CRLF in values to avoid JSON.parse error				
					def values = new ArrayList&amp;lt;String&amp;gt;(r2.values())
					livetableRows['cell'] = []
                    def newdate = new Date().parse("yyyyMMddHHmmssz", rec['fetchAt'])
                    livetableRows['cell'].add(newdate.format('yyyy/MM/dd HH:mm:ss z'))
					values.each{s-&amp;gt;
					    if(s instanceof java.lang.String){
						    def newVal = s.replaceAll("\\\\","/")
							s = newVal.replaceAll("\r\n","")
							newVal = s.replaceAll("\r","")
							s = newVal.replaceAll("\n","")
						    livetableRows['cell'].add(s)
						}else
						  livetableRows['cell'].add(s)
					}
					if(dataModel != null &amp;amp;&amp;amp; dataModel.size() &amp;lt;=0){ 
						dataModel = new ArrayList&amp;lt;String&amp;gt;(r2.keySet());
					}
					rootLivetableRowList.add(livetableRows)
					idx++
				}	
		}		
		rootLivetableData["records"] = rootLivetableRowList.size()
		
		rootLivetableData["total"] =  Math.round(rootLivetableRowList.size()/rows.toInteger())  //total page 
		rootLivetableData["page"] = (page != null)?page:1
		rootLivetableData["rows"] = rootLivetableRowList
		rootLivetableData["userdata"] = [:]
		rootLivetableData["dataModel"] = dataModel 
				
		sortedResultData = rootLivetableRowList		
		//-- convert sidx to 
		if(sord != null){
		   //-- sorting
		   def arrayMap1 = rootLivetableRowList.toArray(rootLivetableRowList)
		   Arrays.sort(arrayMap1, new Comparator() {
			   public int compare(arg0, arg1) {
					def p = arg1
					def n = arg0
					//-- sort by id first, late we sort by sidx req. pam.
					int lv = (sord.equals("desc"))?p["id"].compareTo(n["id"]):n["id"].compareTo(p["id"])
					if (lv &amp;gt; 0) {
							return 1
					} else if (lv &amp;lt; 0) {
							return -1
					} else {
							return 0
					}
						return lv
				}
			})				
			sortedResultData = arrayMap1			
			//-- Apply filter based on rows and page of request parameters
			if(rows != null &amp;amp;&amp;amp; page != null){				
				def startNum = rows.toInteger()*(page.toInteger() - 1)
				def endNum = rows.toInteger()*page.toInteger()-1
				if (arrayMap1.size() &amp;gt; rows.toInteger()) {
					sortedResultData = arrayMap1.getAt(startNum..endNum)
				} else {
					sortedResultData = arrayMap1
				}
			}
			rootLivetableData["rows"] = sortedResultData
		}		
		//if( rootLivetableData != null &amp;amp;&amp;amp; rootLivetableData.size() &amp;gt; 0 ){		
			//-- Parsing generate parameter 
			def builder = new JsonBuilder(rootLivetableData)		
			if(genPam != null &amp;amp;&amp;amp; genPam.equals("1")){
			    def pagerName = request.get("pager")
				if(pagerName == null || pagerName.equals(""))
				   str = "Must specify parameter pager incase you want to build data model (with genp parameter)"				
				def dataUrl =  ""
				if(subType == null || subType == "")
					dataUrl = "/xwiki/bin/get/Lib/LivetableDataAdapter?outputSyntax=plain&amp;amp;job="+job +"&amp;amp;limit="+limit+"&amp;amp;fromDate="+fromDate + "&amp;amp;toDate=" + toDate + "&amp;amp;istIid="+istIid
				else
					dataUrl = "/xwiki/bin/get/Lib/LivetableDataAdapter?outputSyntax=plain&amp;amp;job="+job +"&amp;amp;limit="+limit+"&amp;amp;fromDate="+fromDate + "&amp;amp;toDate=" + toDate + "&amp;amp;istIid="+istIid+"&amp;amp;subType="+subType
				
				//-- Building data model				
				def model = []
				def colSpec
				dataModel.each{name-&amp;gt;
				    colSpec = [:]
					colSpec['name'] = name
					colSpec['index'] = name
					colSpec['width'] = "100"
					model.add(colSpec)
				}
				def dataModelStr = (new JsonBuilder(dataModel)).toPrettyString()
				def modelStr = (new JsonBuilder(model)).toPrettyString() 

				def sortStr = (sord == null || sord.equals(""))?"asc":sord				
				str = 
				"{\"url\":\""+dataUrl+"\",\"datatype\":\"json\","+
					"\"colNames\":"+ dataModelStr +
					",\"colModel\":"+ modelStr +" ,\"rowList\":[10,20,30],"+
					"\"pager\":\"#"+pagerName+"\", \"viewrecords\": true, \"sortname\": \"RECORD_SEQ\","+
					"\"sortorder\": \""+ sortStr +"\", \"caption\":\""+job+"\"}"
				println str 
				
			}else{					
				str = builder.toPrettyString()							
				println str 
			}				
		//}		
    }
    
{{/groovy}}&lt;/content&gt;&lt;/xwikidoc&gt;
@


15.1
log
@@
text
@d14 3
a16 3
&lt;date&gt;1376477141000&lt;/date&gt;
&lt;contentUpdateDate&gt;1376477141000&lt;/contentUpdateDate&gt;
&lt;version&gt;15.1&lt;/version&gt;
d84 1
a84 1
                    livetableRows['cell'].add(newDate.format('yyyy/MM/dd HH:mm:ss z'))
@


14.1
log
@@
text
@d14 3
a16 3
&lt;date&gt;1376476328000&lt;/date&gt;
&lt;contentUpdateDate&gt;1376476328000&lt;/contentUpdateDate&gt;
&lt;version&gt;14.1&lt;/version&gt;
d83 2
a84 1
                    livetableRows['cell'].add(rec['fetchAt'])
@


13.1
log
@@
text
@&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xwikidoc&gt;
&lt;web&gt;Lib&lt;/web&gt;
&lt;name&gt;LivetableDataAdapter&lt;/name&gt;
&lt;language&gt;&lt;/language&gt;
&lt;defaultLanguage&gt;en&lt;/defaultLanguage&gt;
&lt;translation&gt;0&lt;/translation&gt;
&lt;parent&gt;Main.SpaceIndex&lt;/parent&gt;
&lt;creator&gt;XWiki.Admin&lt;/creator&gt;
&lt;author&gt;XWiki.Admin&lt;/author&gt;
&lt;customClass&gt;&lt;/customClass&gt;
&lt;contentAuthor&gt;XWiki.Admin&lt;/contentAuthor&gt;
&lt;creationDate&gt;1376364375000&lt;/creationDate&gt;
&lt;date&gt;1376474691000&lt;/date&gt;
&lt;contentUpdateDate&gt;1376474691000&lt;/contentUpdateDate&gt;
&lt;version&gt;13.1&lt;/version&gt;
&lt;title&gt;LivetableDataAdapter&lt;/title&gt;
&lt;defaultTemplate&gt;&lt;/defaultTemplate&gt;
&lt;validationScript&gt;&lt;/validationScript&gt;
&lt;comment&gt;&lt;/comment&gt;
&lt;minorEdit&gt;false&lt;/minorEdit&gt;
&lt;syntaxId&gt;xwiki/2.1&lt;/syntaxId&gt;
&lt;hidden&gt;false&lt;/hidden&gt;
&lt;content&gt;{{include document="Lib.MongoDBConnection"/}}
{{groovy}}
    import groovy.json.*
    if(request.xpage == "plain") {
	response.setContentType('text/html')
    }    
    def rootLivetableRowList = []
    def rootLivetableData = [:]
    def legacyData = []
    def sortedResultData = [:]
    def dataModel = []
	
    def job = request.get("job")
	
    def fromDate = request.get("fromDate")	
    def toDate = request.get("toDate")
    def limit= (request.get("limit")!=null)?request.get("limit").toInteger():10
	
    def page = request.get("page")
    def rows = (request.get("rows") != null &amp;amp;&amp;amp; !request.get("rows").equals(""))?request.get("rows"):20
    def sidx = request.get("sidx")
    def sord = request.get("sord")
    def genPam = request.get("genp")
    def istIid = request.get("istIid")
    def subType = request.get("subType")
    if(subType != null)
        subType = subType.replaceAll("\"","")
    	
    
    def str= "No data were retrieved!"
    def result = null
    if(job!="" &amp;amp;&amp;amp; job!=null &amp;amp;&amp;amp; istIid != null &amp;amp;&amp;amp; !istIid.equals("")){
        MongoDBConnection.getConnection()
        if(fromDate != "" || toDate != ""){
            result = MongoDBConnection.getDataInPeriod(job,fromDate,toDate,limit,istIid)
        } else {
            result = MongoDBConnection.getDataAllFields(job,limit,istIid)
        }
        MongoDBConnection.closeConnection()       
        
		def idx =0               
		result.each{rec-&amp;gt;		
			//-- get a list of data row
			legacyData = rec['data']
			subtractData = []
			//-- Parsing data and assign data to subtract list
			if(subType == null || subType.equals("")){ //-- Store
				subtractData = legacyData
			}else{ //-- Subtype
				def subTypeDataList = legacyData[subType]
				subtractData = subTypeDataList
			}	
			subtractData.each{r2-&amp;gt;
					def livetableRows = [:]
					livetableRows['id'] = rec['fetchAt'] + "_" + idx				
					//-- replace CRLF in values to avoid JSON.parse error				
					def values = new ArrayList&amp;lt;String&amp;gt;(r2.values())
					livetableRows['cell'] = []
					values.each{s-&amp;gt;
                        livetableRows['cell'].add(rec['fetchAt'])
					    if(s instanceof java.lang.String){
						    def newVal = s.replaceAll("\\\\","/")
							s = newVal.replaceAll("\r\n","")
							newVal = s.replaceAll("\r","")
							s = newVal.replaceAll("\n","")
						    livetableRows['cell'].add(s)
						}else
						  livetableRows['cell'].add(s)
					}
					if(dataModel != null &amp;amp;&amp;amp; dataModel.size() &amp;lt;=0){ 
						dataModel = new ArrayList&amp;lt;String&amp;gt;(r2.keySet());
					}
					rootLivetableRowList.add(livetableRows)
					idx++
				}	
		}		
		rootLivetableData["records"] = rootLivetableRowList.size()
		
		rootLivetableData["total"] =  Math.round(rootLivetableRowList.size()/rows.toInteger())  //total page 
		rootLivetableData["page"] = (page != null)?page:1
		rootLivetableData["rows"] = rootLivetableRowList
		rootLivetableData["userdata"] = [:]
		rootLivetableData["dataModel"] = dataModel 
				
		sortedResultData = rootLivetableRowList		
		//-- convert sidx to 
		if(sord != null){
		   //-- sorting
		   def arrayMap1 = rootLivetableRowList.toArray(rootLivetableRowList)
		   Arrays.sort(arrayMap1, new Comparator() {
			   public int compare(arg0, arg1) {
					def p = arg1
					def n = arg0
					//-- sort by id first, late we sort by sidx req. pam.
					int lv = (sord.equals("desc"))?p["id"].compareTo(n["id"]):n["id"].compareTo(p["id"])
					if (lv &amp;gt; 0) {
							return 1
					} else if (lv &amp;lt; 0) {
							return -1
					} else {
							return 0
					}
						return lv
				}
			})				
			sortedResultData = arrayMap1			
			//-- Apply filter based on rows and page of request parameters
			if(rows != null &amp;amp;&amp;amp; page != null){				
				def startNum = rows.toInteger()*(page.toInteger() - 1)
				def endNum = rows.toInteger()*page.toInteger()-1
				if (arrayMap1.size() &amp;gt; rows.toInteger()) {
					sortedResultData = arrayMap1.getAt(startNum..endNum)
				} else {
					sortedResultData = arrayMap1
				}
			}
			rootLivetableData["rows"] = sortedResultData
		}		
		//if( rootLivetableData != null &amp;amp;&amp;amp; rootLivetableData.size() &amp;gt; 0 ){		
			//-- Parsing generate parameter 
			def builder = new JsonBuilder(rootLivetableData)		
			if(genPam != null &amp;amp;&amp;amp; genPam.equals("1")){
			    def pagerName = request.get("pager")
				if(pagerName == null || pagerName.equals(""))
				   str = "Must specify parameter pager incase you want to build data model (with genp parameter)"				
				def dataUrl =  ""
				if(subType == null || subType == "")
					dataUrl = "/xwiki/bin/get/Lib/LivetableDataAdapter?outputSyntax=plain&amp;amp;job="+job +"&amp;amp;limit="+limit+"&amp;amp;fromDate="+fromDate + "&amp;amp;toDate=" + toDate + "&amp;amp;istIid="+istIid
				else
					dataUrl = "/xwiki/bin/get/Lib/LivetableDataAdapter?outputSyntax=plain&amp;amp;job="+job +"&amp;amp;limit="+limit+"&amp;amp;fromDate="+fromDate + "&amp;amp;toDate=" + toDate + "&amp;amp;istIid="+istIid+"&amp;amp;subType="+subType
				
				//-- Building data model				
				def model = []
				def colSpec
				dataModel.each{name-&amp;gt;
				    colSpec = [:]
					colSpec['name'] = name
					colSpec['index'] = name
					colSpec['width'] = "100"
					model.add(colSpec)
				}
				def dataModelStr = (new JsonBuilder(dataModel)).toPrettyString()
				def modelStr = (new JsonBuilder(model)).toPrettyString() 

				def sortStr = (sord == null || sord.equals(""))?"asc":sord				
				str = 
				"{\"url\":\""+dataUrl+"\",\"datatype\":\"json\","+
					"\"colNames\":"+ dataModelStr +
					",\"colModel\":"+ modelStr +" ,\"rowList\":[10,20,30],"+
					"\"pager\":\"#"+pagerName+"\", \"viewrecords\": true, \"sortname\": \"RECORD_SEQ\","+
					"\"sortorder\": \""+ sortStr +"\", \"caption\":\""+job+"\"}"
				println str 
				
			}else{					
				str = builder.toPrettyString()							
				println str 
			}				
		//}		
    }
    
{{/groovy}}&lt;/content&gt;&lt;/xwikidoc&gt;
@


12.5
log
@@
text
@d14 3
a16 3
&lt;date&gt;1376369683000&lt;/date&gt;
&lt;contentUpdateDate&gt;1376369683000&lt;/contentUpdateDate&gt;
&lt;version&gt;12.5&lt;/version&gt;
d21 1
a21 1
&lt;minorEdit&gt;true&lt;/minorEdit&gt;
d48 4
d57 4
a60 4
	if(fromDate != "" || toDate != ""){
		result = MongoDBConnection.getDataInPeriod(job,fromDate,toDate,limit,istIid)
	} else {
		result = MongoDBConnection.getDataAllFields(job,limit,istIid)
d62 2
a63 1
        MongoDBConnection.closeConnection()               
d68 32
a99 24
			legacyData.each{r2-&amp;gt;
				def livetableRows = [:]
				livetableRows['id'] = rec['fetchAt'] + "_" + idx				
				//-- replace CRLF in values to avoid JSON.parse error				
				def values = new ArrayList&amp;lt;String&amp;gt;(r2.values())
				livetableRows['cell'] = []
				values.each{s-&amp;gt;
				    if(s instanceof java.lang.String){
					    def newVal = s.replaceAll("\\\\","/")
						s = newVal.replaceAll("\r\n","")
						newVal = s.replaceAll("\r","")
						s = newVal.replaceAll("\n","")
					    livetableRows['cell'].add(s)
					}else
					  livetableRows['cell'].add(s)
				}
				if(dataModel != null &amp;amp;&amp;amp; dataModel.size() &amp;lt;=0){ 
					dataModel = new ArrayList&amp;lt;String&amp;gt;(r2.keySet());
				}
				rootLivetableRowList.add(livetableRows)
				idx++
			}			
		}
		rootLivetableRowList.size()
d128 4
a131 7
			})
				
			sortedResultData = arrayMap1
			
			//-- apply filter
			if(rows != null &amp;amp;&amp;amp; page != null){
				//get records by rows and page on request parameter
d141 1
a141 2
		}
		
d149 5
a153 1
				def dataUrl =  "/xwiki/bin/get/Lib/LivetableDataAdapter?outputSyntax=plain&amp;amp;job="+job +"&amp;amp;limit="+limit+"&amp;amp;fromDate="+fromDate + "&amp;amp;toDate=" + toDate + "&amp;amp;istIid="+istIid
@


12.4
log
@@
text
@d14 3
a16 3
&lt;date&gt;1376369125000&lt;/date&gt;
&lt;contentUpdateDate&gt;1376369125000&lt;/contentUpdateDate&gt;
&lt;version&gt;12.4&lt;/version&gt;
d58 1
a58 5
        MongoDBConnection.closeConnection()
                //println "{{html}}"
                println "result size" + result.size()
                println "Job" + job +"---- limit = " + limit +"---- istIid = "+istIid
                //println "{{/html}}"
@


12.3
log
@@
text
@d14 3
a16 3
&lt;date&gt;1376368934000&lt;/date&gt;
&lt;contentUpdateDate&gt;1376368934000&lt;/contentUpdateDate&gt;
&lt;version&gt;12.3&lt;/version&gt;
d53 6
a58 6
		if(fromDate != "" || toDate != ""){
			result = MonoDBConnection.getDataInPeriod(job,fromDate,toDate,limit, istIid)
		} else 
		{
			result = MongoDBConnection.getDataAllFields(job,limit, istIid)
		}
@


12.2
log
@@
text
@d14 3
a16 3
&lt;date&gt;1376368851000&lt;/date&gt;
&lt;contentUpdateDate&gt;1376368851000&lt;/contentUpdateDate&gt;
&lt;version&gt;12.2&lt;/version&gt;
d61 1
@


12.1
log
@@
text
@&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xwikidoc&gt;
&lt;web&gt;Lib&lt;/web&gt;
&lt;name&gt;LivetableDataAdapter&lt;/name&gt;
&lt;language&gt;&lt;/language&gt;
&lt;defaultLanguage&gt;en&lt;/defaultLanguage&gt;
&lt;translation&gt;0&lt;/translation&gt;
&lt;parent&gt;Main.SpaceIndex&lt;/parent&gt;
&lt;creator&gt;XWiki.Admin&lt;/creator&gt;
&lt;author&gt;XWiki.Admin&lt;/author&gt;
&lt;customClass&gt;&lt;/customClass&gt;
&lt;contentAuthor&gt;XWiki.Admin&lt;/contentAuthor&gt;
&lt;creationDate&gt;1376364375000&lt;/creationDate&gt;
&lt;date&gt;1376368813000&lt;/date&gt;
&lt;contentUpdateDate&gt;1376368813000&lt;/contentUpdateDate&gt;
&lt;version&gt;12.1&lt;/version&gt;
&lt;title&gt;LivetableDataAdapter&lt;/title&gt;
&lt;defaultTemplate&gt;&lt;/defaultTemplate&gt;
&lt;validationScript&gt;&lt;/validationScript&gt;
&lt;comment&gt;&lt;/comment&gt;
&lt;minorEdit&gt;false&lt;/minorEdit&gt;
&lt;syntaxId&gt;xwiki/2.1&lt;/syntaxId&gt;
&lt;hidden&gt;false&lt;/hidden&gt;
&lt;content&gt;{{include document="Lib.MongoDBConnection"/}}
{{groovy}}
    import groovy.json.*
    if(request.xpage == "plain") {
	response.setContentType('text/html')
    }    
    def rootLivetableRowList = []
    def rootLivetableData = [:]
    def legacyData = []
    def sortedResultData = [:]
    def dataModel = []
	
    def job = request.get("job")
	
    def fromDate = request.get("fromDate")	
    def toDate = request.get("toDate")
    def limit= (request.get("limit")!=null)?request.get("limit").toInteger():10
	
    def page = request.get("page")
    def rows = (request.get("rows") != null &amp;amp;&amp;amp; !request.get("rows").equals(""))?request.get("rows"):20
    def sidx = request.get("sidx")
    def sord = request.get("sord")
    def genPam = request.get("genp")
    def istIid = request.get("istIid")
    
    def str= "No data were retrieved!"
    def result = null
    if(job!="" &amp;amp;&amp;amp; job!=null &amp;amp;&amp;amp; istIid != null &amp;amp;&amp;amp; !istIid.equals("")){
        MongoDBConnection.getConnection()
		if(fromDate != "" || toDate != ""){
			result = MonoDBConnection.getDataInPeriod(job,fromDate,toDate,limit, istIid)
		} else 
		{
			result = MongoDBConnection.getDataAllFields(job,limit, istIid)
		}
                println "{{html}}"
                println "result size" + result.size()
                println "{{/html}}"
		def idx =0               
		result.each{rec-&amp;gt;		
			//-- get a list of data row
			legacyData = rec['data']
			legacyData.each{r2-&amp;gt;
				def livetableRows = [:]
				livetableRows['id'] = rec['fetchAt'] + "_" + idx				
				//-- replace CRLF in values to avoid JSON.parse error				
				def values = new ArrayList&amp;lt;String&amp;gt;(r2.values())
				livetableRows['cell'] = []
				values.each{s-&amp;gt;
				    if(s instanceof java.lang.String){
					    def newVal = s.replaceAll("\\\\","/")
						s = newVal.replaceAll("\r\n","")
						newVal = s.replaceAll("\r","")
						s = newVal.replaceAll("\n","")
					    livetableRows['cell'].add(s)
					}else
					  livetableRows['cell'].add(s)
				}
				if(dataModel != null &amp;amp;&amp;amp; dataModel.size() &amp;lt;=0){ 
					dataModel = new ArrayList&amp;lt;String&amp;gt;(r2.keySet());
				}
				rootLivetableRowList.add(livetableRows)
				idx++
			}			
		}
		rootLivetableRowList.size()
		rootLivetableData["records"] = rootLivetableRowList.size()
		
		rootLivetableData["total"] =  Math.round(rootLivetableRowList.size()/rows.toInteger())  //total page 
		rootLivetableData["page"] = (page != null)?page:1
		rootLivetableData["rows"] = rootLivetableRowList
		rootLivetableData["userdata"] = [:]
		rootLivetableData["dataModel"] = dataModel 
				
		sortedResultData = rootLivetableRowList		
		//-- convert sidx to 
		if(sord != null){
		   //-- sorting
		   def arrayMap1 = rootLivetableRowList.toArray(rootLivetableRowList)
		   Arrays.sort(arrayMap1, new Comparator() {
			   public int compare(arg0, arg1) {
					def p = arg1
					def n = arg0
					//-- sort by id first, late we sort by sidx req. pam.
					int lv = (sord.equals("desc"))?p["id"].compareTo(n["id"]):n["id"].compareTo(p["id"])
					if (lv &amp;gt; 0) {
							return 1
					} else if (lv &amp;lt; 0) {
							return -1
					} else {
							return 0
					}
						return lv
				}
			})
				
			sortedResultData = arrayMap1
			
			//-- apply filter
			if(rows != null &amp;amp;&amp;amp; page != null){
				//get records by rows and page on request parameter
				def startNum = rows.toInteger()*(page.toInteger() - 1)
				def endNum = rows.toInteger()*page.toInteger()-1
				if (arrayMap1.size() &amp;gt; rows.toInteger()) {
					sortedResultData = arrayMap1.getAt(startNum..endNum)
				} else {
					sortedResultData = arrayMap1
				}
			}
			rootLivetableData["rows"] = sortedResultData
		}
		
		//if( rootLivetableData != null &amp;amp;&amp;amp; rootLivetableData.size() &amp;gt; 0 ){		
			//-- Parsing generate parameter 
			def builder = new JsonBuilder(rootLivetableData)		
			if(genPam != null &amp;amp;&amp;amp; genPam.equals("1")){
			    def pagerName = request.get("pager")
				if(pagerName == null || pagerName.equals(""))
				   str = "Must specify parameter pager incase you want to build data model (with genp parameter)"				
				def dataUrl =  "/xwiki/bin/get/Lib/LivetableDataAdapter?outputSyntax=plain&amp;amp;job="+job +"&amp;amp;limit="+limit+"&amp;amp;fromDate="+fromDate + "&amp;amp;toDate=" + toDate + "&amp;amp;istIid="+istIid
				
				//-- Building data model				
				def model = []
				def colSpec
				dataModel.each{name-&amp;gt;
				    colSpec = [:]
					colSpec['name'] = name
					colSpec['index'] = name
					colSpec['width'] = "100"
					model.add(colSpec)
				}
				def dataModelStr = (new JsonBuilder(dataModel)).toPrettyString()
				def modelStr = (new JsonBuilder(model)).toPrettyString() 

				def sortStr = (sord == null || sord.equals(""))?"asc":sord				
				str = 
				"{\"url\":\""+dataUrl+"\",\"datatype\":\"json\","+
					"\"colNames\":"+ dataModelStr +
					",\"colModel\":"+ modelStr +" ,\"rowList\":[10,20,30],"+
					"\"pager\":\"#"+pagerName+"\", \"viewrecords\": true, \"sortname\": \"RECORD_SEQ\","+
					"\"sortorder\": \""+ sortStr +"\", \"caption\":\""+job+"\"}"
				println str 
				
			}else{					
				str = builder.toPrettyString()							
				println str 
			}				
		//}		
    }
    
{{/groovy}}&lt;/content&gt;&lt;/xwikidoc&gt;
@


11.3
log
@@
text
@d14 3
a16 3
&lt;date&gt;1376368460000&lt;/date&gt;
&lt;contentUpdateDate&gt;1376368460000&lt;/contentUpdateDate&gt;
&lt;version&gt;11.3&lt;/version&gt;
d21 1
a21 1
&lt;minorEdit&gt;true&lt;/minorEdit&gt;
d59 3
@


11.2
log
@@
text
@d14 3
a16 3
&lt;date&gt;1376368313000&lt;/date&gt;
&lt;contentUpdateDate&gt;1376368313000&lt;/contentUpdateDate&gt;
&lt;version&gt;11.2&lt;/version&gt;
d59 1
a59 2
		def idx =0
                console('abc')
@


11.1
log
@@
text
@d14 3
a16 3
&lt;date&gt;1376366971000&lt;/date&gt;
&lt;contentUpdateDate&gt;1376366971000&lt;/contentUpdateDate&gt;
&lt;version&gt;11.1&lt;/version&gt;
d21 1
a21 1
&lt;minorEdit&gt;false&lt;/minorEdit&gt;
d60 1
@


10.31
log
@Imported from XAR
@
text
@d14 3
a16 3
&lt;date&gt;1376364375000&lt;/date&gt;
&lt;contentUpdateDate&gt;1376364375000&lt;/contentUpdateDate&gt;
&lt;version&gt;10.31&lt;/version&gt;
d20 1
a20 1
&lt;comment&gt;Imported from XAR&lt;/comment&gt;
d47 1
d51 1
a51 1
    if(job!="" &amp;amp;&amp;amp; job!=null){
d54 1
a54 1
			result = MonoDBConnection.getDataInPeriod(job,fromDate,toDate,limit)
d57 1
a57 1
			result = MongoDBConnection.getDataAllFields(job,limit)
d140 1
a140 1
				def dataUrl =  "/xwiki/bin/get/Lib/LivetableDataAdapter?outputSyntax=plain&amp;amp;job="+job +"&amp;amp;limit="+limit+"&amp;amp;fromDate="+fromDate + "&amp;amp;toDate=" + toDate
@
</versions></xwikidoc>